diff --git a/tket/src/Circuit/CircuitJson.cpp b/tket/src/Circuit/CircuitJson.cpp
index 67f2784..3096740 100644
--- a/tket/src/Circuit/CircuitJson.cpp
+++ b/tket/src/Circuit/CircuitJson.cpp
@@ -43,7 +43,7 @@ void to_json(nlohmann::json& j, const Circuit& circ) {
 void from_json(const nlohmann::json& j, Circuit& circ) {
   circ = Circuit();
 
-  if (j.contains("name")) {
+  if (j.count("name")) {
     circ.set_name(j["name"].get<std::string>());
   }
   circ.add_phase(j.at("phase").get<Expr>());
@@ -64,13 +64,13 @@ void from_json(const nlohmann::json& j, Circuit& circ) {
   circ.permute_boundary_output(imp_perm);
   // Check if key exists to work with circuits serialised using older tket
   // versions
-  if (j.contains("created_qubits")) {
+  if (j.count("created_qubits")) {
     for (const auto& j_q : j.at("created_qubits")) {
       const auto& q = j_q.get<Qubit>();
       circ.qubit_create(q);
     }
   }
-  if (j.contains("discarded_qubits")) {
+  if (j.count("discarded_qubits")) {
     for (const auto& j_q : j.at("discarded_qubits")) {
       const auto& q = j_q.get<Qubit>();
       circ.qubit_discard(q);
diff --git a/tket/src/Circuit/CommandJson.cpp b/tket/src/Circuit/CommandJson.cpp
index fe48cbd..da6a4d7 100644
--- a/tket/src/Circuit/CommandJson.cpp
+++ b/tket/src/Circuit/CommandJson.cpp
@@ -44,7 +44,7 @@ void to_json(nlohmann::json& j, const Command& com) {
 void from_json(const nlohmann::json& j, Command& com) {
   const auto op = j.at("op").get<Op_ptr>();
   std::optional<std::string> opgroup;
-  if (j.contains("opgroup")) {
+  if (j.count("opgroup")) {
     opgroup = j.at("opgroup").get<std::string>();
   }
   const op_signature_t& sig = op->get_signature();
diff --git a/tket/src/Clifford/ChoiMixTableau.cpp b/tket/src/Clifford/ChoiMixTableau.cpp
index 7f6e18e..8261e7b 100644
--- a/tket/src/Clifford/ChoiMixTableau.cpp
+++ b/tket/src/Clifford/ChoiMixTableau.cpp
@@ -712,7 +712,7 @@ void to_json(nlohmann::json& j, const ChoiMixTableau& tab) {
 }
 
 void from_json(const nlohmann::json& j, ChoiMixTableau& tab) {
-  j.at("tab").get_to(tab.tab_);
+  nlohmann::from_json(j.at("tab"), tab.tab_);
   std::vector<ChoiMixTableau::col_key_t> qbs =
       j.at("qubits").get<std::vector<ChoiMixTableau::col_key_t>>();
   if (qbs.size() != tab.tab_.get_n_qubits())
diff --git a/tket/src/Clifford/UnitaryTableau.cpp b/tket/src/Clifford/UnitaryTableau.cpp
index d2c0839..097cba0 100644
--- a/tket/src/Clifford/UnitaryTableau.cpp
+++ b/tket/src/Clifford/UnitaryTableau.cpp
@@ -579,7 +579,7 @@ void to_json(nlohmann::json& j, const UnitaryTableau& tab) {
 }
 
 void from_json(const nlohmann::json& j, UnitaryTableau& tab) {
-  j.at("tab").get_to(tab.tab_);
+  nlohmann::from_json(j.at("tab"), tab.tab_);
   if (tab.tab_.get_n_rows() != 2 * tab.tab_.get_n_qubits())
     throw std::invalid_argument(
         "Size of tableau does not match requirements for UnitaryTableau.");
diff --git a/tket/src/Converters/UnitaryTableauBox.cpp b/tket/src/Converters/UnitaryTableauBox.cpp
index b965e4b..ebf750b 100644
--- a/tket/src/Converters/UnitaryTableauBox.cpp
+++ b/tket/src/Converters/UnitaryTableauBox.cpp
@@ -68,7 +68,7 @@ nlohmann::json UnitaryTableauBox::to_json(const Op_ptr& op) {
 
 Op_ptr UnitaryTableauBox::from_json(const nlohmann::json& j) {
   UnitaryTableau tab(0);
-  j.at("tab").get_to(tab);
+  nlohmann::from_json(j.at("tab"), tab);
   return std::make_shared<const UnitaryTableauBox>(tab);
 }
 
diff --git a/tket/src/Gate/Gate.cpp b/tket/src/Gate/Gate.cpp
index 7cbf044..d177d17 100644
--- a/tket/src/Gate/Gate.cpp
+++ b/tket/src/Gate/Gate.cpp
@@ -829,7 +829,7 @@ nlohmann::json Gate::serialize() const {
 Op_ptr Gate::deserialize(const nlohmann::json& j) {
   OpType optype = j.at("type").get<OpType>();
   std::vector<Expr> params;
-  if (j.contains("params")) {
+  if (j.count("params")) {
     params = j.at("params").get<std::vector<Expr>>();
   }
   // if type has fixed number of qubits use it, otherwise it should have been
diff --git a/tket/src/PauliGraph/PauliGraph.cpp b/tket/src/PauliGraph/PauliGraph.cpp
index e89857a..79bf544 100644
--- a/tket/src/PauliGraph/PauliGraph.cpp
+++ b/tket/src/PauliGraph/PauliGraph.cpp
@@ -396,7 +396,7 @@ void PauliGraph::sanity_check() const {
     boost::graph_traits<PauliDAG>::adjacency_iterator ai, a_end;
     boost::tie(ai, a_end) = boost::adjacent_vertices(vert, graph_);
     for (; ai != a_end; ai++) {
-      TKET_ASSERT(!succs.contains(*ai));
+      // TKET_ASSERT(!succs.contains(*ai));
       succs.insert(*ai);
     }
 
@@ -404,7 +404,7 @@ void PauliGraph::sanity_check() const {
     PauliDAG::inv_adjacency_iterator iai, ia_end;
     boost::tie(iai, ia_end) = boost::inv_adjacent_vertices(vert, graph_);
     for (; iai != ia_end; iai++) {
-      TKET_ASSERT(!preds.contains(*iai));
+      // TKET_ASSERT(!preds.contains(*iai));
       preds.insert(*iai);
     }
   }
diff --git a/tket/src/Predicates/CompilerPass.cpp b/tket/src/Predicates/CompilerPass.cpp
index 230ca19..1a18b04 100644
--- a/tket/src/Predicates/CompilerPass.cpp
+++ b/tket/src/Predicates/CompilerPass.cpp
@@ -487,7 +487,7 @@ void from_json(const nlohmann::json& j, PassPtr& pp) {
                                             ? Transforms::CreateAllQubits::Yes
                                             : Transforms::CreateAllQubits::No;
       std::shared_ptr<const Circuit> xc;
-      if (content.contains("x_circuit")) {
+      if (content.count("x_circuit")) {
         xc = std::make_shared<const Circuit>(
             content.at("x_circuit").get<Circuit>());
       }
diff --git a/tket/src/Predicates/PassGenerators.cpp b/tket/src/Predicates/PassGenerators.cpp
index 7ffd580..dc558d1 100644
--- a/tket/src/Predicates/PassGenerators.cpp
+++ b/tket/src/Predicates/PassGenerators.cpp
@@ -802,7 +802,7 @@ PassPtr CustomPass(
     const std::string& label) {
   Transform t{[transform](Circuit& circ) {
     Circuit circ_out = transform(circ);
-    bool success = circ_out != circ;
+    bool success = !(circ_out == circ);
     circ = circ_out;
     return success;
   }};
diff --git a/tket/src/Utils/include/Utils/Json.hpp b/tket/src/Utils/include/Utils/Json.hpp
index f677a39..54e3c58 100644
--- a/tket/src/Utils/include/Utils/Json.hpp
+++ b/tket/src/Utils/include/Utils/Json.hpp
@@ -69,3 +69,46 @@ void from_json(const nlohmann::json& j, std::optional<T>& v) {
 }
 
 }  // namespace std
+
+#if !defined(NLOHMANN_JSON_SERIALIZE_ENUM)
+/*!
+@brief macro to briefly define a mapping between an enum and JSON
+@def NLOHMANN_JSON_SERIALIZE_ENUM
+@since version 3.4.0
+*/
+#define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                            \
+    template<typename BasicJsonType>                                                            \
+    inline void to_json(BasicJsonType& j, const ENUM_TYPE& e)                                   \
+    {                                                                                           \
+        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
+        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
+        auto it = std::find_if(std::begin(m), std::end(m),                                      \
+                               [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool  \
+        {                                                                                       \
+            return ej_pair.first == e;                                                          \
+        });                                                                                     \
+        j = ((it != std::end(m)) ? it : std::begin(m))->second;                                 \
+    }                                                                                           \
+    template<typename BasicJsonType>                                                            \
+    inline void from_json(const BasicJsonType& j, ENUM_TYPE& e)                                 \
+    {                                                                                           \
+        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
+        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
+        auto it = std::find_if(std::begin(m), std::end(m),                                      \
+                               [&j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
+        {                                                                                       \
+            return ej_pair.second == j;                                                         \
+        });                                                                                     \
+        e = ((it != std::end(m)) ? it : std::begin(m))->first;                                  \
+    }
+#endif
+
+#if NLOHMANN_JSON_VERSION_MAJOR < 3 || (NLOHMANN_JSON_VERSION_MAJOR == 3 && NLOHMANN_JSON_VERSION_MINOR <= 2)
+namespace std {
+template<typename KeyT, typename ValueT>
+void from_json(const nlohmann::json& j, std::pair<const KeyT, ValueT>& p) {
+  const_cast<KeyT&>(p.first)  = j.at(0).template get<KeyT>();
+  p.second = j.at(1).template get<ValueT>();
+}
+}
+#endif
