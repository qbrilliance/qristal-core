# 7. Download and Installation

qbOS consists of a front-end JupyterLab GUI, supported by a container that is run on any of the following platforms:

## 7.1 qbOS Jupyter UI through Pawsey Nimbus Cloud

## 7.2 qbOS Jupyter UI through AWS

## 7.3 qbOS CLI and job scripts (for HPC usage)

qbOS includes command-line executables that are suited for job scripts that are submitted to queues on HPC systems.  These are executables that are compiled from source code to use site-specific optimised numerical libraries and MPI support.  Execution can be performed either on containers (Singularity); or directly on bare metal.  Please contact Quantum Brilliance to discuss your requirements.

## 7.4 Offload to standalone simulators

### 7.4.1 Aer standalone `qasm_simulator` (tensor-network capable)

<aside>
⚠️ **Deprecated in qbOS version 2.0**

**Replacement functionality:** 
From qbOS version 2.0 onward, use the `aer-mps` simulator directly from qbOS as follows:

```python
import qbos
tqb = qbos.core()
tqb.qb12()

tqb.acc = "aer"
tqb.aer_sim_type = "matrix_product_state"
```

- Previous description (for qbOS version 1)
    
    <aside>
    ✅ This is an advanced option: qbOS is pre-installed with a standalone matrix-product-state (MPS) tensor network simulator configured to use the Quantum Brilliance 48-qubit noise model.  
    
    qbOS provides the means to generate the required qobj JSON input. The noise model is also made available in JSON format.
    
    </aside>
    
    Usage:
    
    ```python
    # In qbOS Jupyter notebook:
    resultjson = ! qasm_simulator -c /mnt/qb/share/aer_noise_model_qb.json <your-input.qobj>
    
    ```
    
    Example:
    
    Below is a full qbOS Jupyter notebook that generates a qobj, and then calls the standalone Aer `qasm_simulator`:
    
    ```python
    import qbos
    import json
    tqb=qbos.core()
    tqb.qb12()
    tqb.acc = "aer"
    tqb.nosim = True  # bypass execution with XACC-aer, but generate the qobj
    tqb.instring='''
    __qpu__ void QBCIRCUIT(qreg q) {
    OPENQASM 2.0;
    include "qelib1.inc";
    creg c[2];
    h q[1];
    cx q[1],q[0];
    measure q[1] -> c[1];
    measure q[0] -> c[0];
    }
    '''
    
    tqb.run()
    # Save qobj to a file
    ofp = open("btest.qobj", mode='w')
    print(tqb.out_qobj[0][0],file=ofp)
    ofp.close()
    
    aerd = ! qasm_simulator -c /mnt/qb/share/aer_noise_model_qb.json btest.qobj
    resj = json.loads(''.join(aerd))
    
    # Show the counts
    resj['results'][0]['data']['counts']
    
    # Output: {'0x0': 493, '0x1': 11, '0x2': 10, '0x3': 510}
    ```
    
</aside>

## 7.5 AWS Braket offloading

[AWS Braket offload in qbOS](qbOS%20Documentation%20220913/AWS%20Braket%20offload%20in%20qbOS%204631d07005d74d5898dc4ee153199663.md)

