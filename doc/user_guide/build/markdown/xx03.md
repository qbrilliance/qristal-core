# 2. Learn Quantum Gates

## 2.1. Introduction

As with the bits of classical computing, qubits must be manipulated and read to be of any use. Here we have given brief descriptions, with examples of some of the more important quantum gates.

## 2.2. Quantum measurement with and without noise

Arguably the most important operation in a quantum circuit, the quantum measurement is typically the last operation, although not every qubit is necessarily measured. There are several important differences concerning measurement between quantum and classical circuits:

- Measuring the state of a qubit ends its role in the calculation, as well as that of any qubit that was entangled with it. This is in contrast to classical bits whose values can be read and used elsewhere whilst allowing the calculation to continue. "Entangled" can be reasonably described as "correlated" for our purposes here and we shall describe it properly below.
- The state of a qubit cannot be duplicated, unlike a classical bit for which a branching gate exists. There is no such gate in quantum computing, a fact expressed by the "no-cloning" theorem. It is possible to copy a qubit's state onto another qubit of known, typically zero value, but the two qubits remain entangled and cannot be regarded as independent.
- A qubit is generally in a superposition of $`|0\rangle`$ and $`|1\rangle`$ states but only of those values is returned upon measurement. Which of the two are a genuinely random outcome and identical preparations may return different results. Regardless of how they may be separated in time or space, measurements of qubits will always correlate correctly if they are interdependent in any way.

In order to manage and study these random outcomes qbOS has the capacity to run a circuit multiple times, called shots. The returned qubit values are accompanied by the number of shots for which they were found by the final measurement.

There is another source of randomness in a quantum circuit, namely the thermal, magnetic and other noise acting on the qubits. qbOS can include this noise in its simulations if desired. The parameters for this noise are hard-coded to match the characteristics of the QB's hardware. The following code example sets up three qubits, setting one of them to $`|1\rangle`$, and measures them for 1024 shots. 

Python code:

```python
import qbos as q
tqb = q.core()
tqb.qb12()

tqb.instring = '''
__qpu__ void QBCIRCUIT(qreg q) {
OPENQASM 2.0;
include "qelib1.inc";
creg c[3];

// ----- q[2] -----;----- q[1] -----;----- q[0] -----;
                                         x q[0]      ;

measure q[2] -> c[2];
measure q[1] -> c[1];
measure q[0] -> c[0];
}
'''

tqb.sn = 1024
tqb.acc = "aer"
tqb.noise[0].clear()
sweep = [False,True]
[tqb.noise[0].append(bb) for bb in sweep]

tqb.run()
```

Inspect the results:

```python
tqb.out_count[0]
```

The result is (similar to) this:

```python
[{1: 1024}, {0: 9, 1: 990, 3: 11, 5: 14}]
```

The 'sweep' variable was used to run both noise-free (False) and with noise (True). The first set of curly brackets is the noise-free result the same correct result is found for each shot. The second indicates the effects of noise although the correct result in this case still comprises the great majority of outcomes.

## 2.3 Simple gates

The simplest operations are those that either switch a qubit's state between $`|0\rangle`$ and $`|1\rangle`$ or change its coefficient. The very simplest is the identity operator which does literally nothing. It is equivalent to multiplying a number by one and is generally included only to complete the algebra generated by other operations.

The other operations for simply switching and multiplying qubits are denoted X, Y and Z: 

- X-gate: Interchanges  $`|0\rangle`$ and $`|1\rangle`$ with no other effects. It is also called the NOT gate,
- Y-gate: Maps $`|0\rangle`$ to $`i|1\rangle`$ and $`|1\rangle`$ to $`-i|0\rangle`$,
- Z-gate: Leaves $`|0\rangle`$ unchanged but multiplies $`|1\rangle`$ by -1.

What makes quantum computing interesting however is that the qubits are not restricted to be multiples of either $`|0\rangle`$ or  $`|1\rangle`$ but may exist in a superposition of the two. The simplest way to create such a superposition is with the Hadamard gate, usually represented with an 'H'. The effect of the Hadamard gate is as follows:

- $`|0\rangle \longrightarrow \frac{1}{\sqrt{2}} \left( |0\rangle + |1\rangle \right)`$
- $`|1\rangle \longrightarrow \frac{1}{\sqrt{2}} \left( |0\rangle - |1\rangle \right)`$

Each of these gates is its own inverse, meaning that applying it twice in a row leaves the qubit unchanged, so 

$`I = H^2 = X^2 = Y^2 = Z^2`$.

## 2.4 Simple quantum circuit with a Hadamard gate

We start with qbOS libraries import and some global configs: 

```python
import qbos
tqb = qbos.core()  # This object has access to the core API methods for circuit simulation
tqb.qb12()         # Set up some sensible defaults
```

Setting up some experiments' options:

```python
tqb.xasm = True    # Use XASM circuit format 
tqb.noise = True   
tqb.acc = "aer"    # Use the aer state-vector simulator with QB's embedded noise model 
```

Inserting the quantum circuits through the assembly language:

```python
# Option 1: a single H-gate (minimising the circuit depth)
tqb.instring = '''            
__qpu__ void QBCIRCUIT(qreg q) {
H(q[0]); // notice we initialise at |0> by default 
Measure(q[0]);
}
'''
```

```python
# Option 2: the equivalent circuit thru optimal native gate set of QB hardware
tqb.instring = '''            
__qpu__ void QBCIRCUIT(qreg q) {
Ry(q[0],pi/2);
X(q[0]);
Measure(q[0]);
}
'''
```

Setting up going through two experiments with different number of shots:

```python
tqb.sn[0].clear()
sweep = [1,100]
[tqb.sn[0].append(nn) for nn in sweep]
```

Running the circuits:

```python
tqb.run()
```

Inspecting the stochastic results:

```python
print(tqb.out_raw[0][0])
```

```python
print(tqb.out_raw[0][1])
```

```
{
"1":1
}
```

```
{
"0":56,
"1":44,
}
```

Using Python tools to get histograms:

```python
import numpy as np
import matplotlib.pyplot as plt
from pylab import figure, show, legend, ylabel
fig1 = figure()
ax1 = fig1.add_subplot(111)
xdat=[format(iix,'01b') for iix in iter(tqb.out_count[0][0])]
ydat=[tqb.out_count[0][0][iiy] for iiy in iter(tqb.out_count[0][0])]
ax1.bar(xdat,ydat)
plt.yticks(np.arange(0, 1.001, step=1))
plt.xlabel("States")
plt.ylabel("Shots measured")
```

```python
import numpy as np
import matplotlib.pyplot as plt
from pylab import figure, show, legend, ylabel
fig1 = figure()
ax1 = fig1.add_subplot(111)
xdat=[format(iix,'01b') for iix in iter(tqb.out_count[0][1])]
ydat=[tqb.out_count[0][1][iiy] for iiy in iter(tqb.out_count[0][1])]
ax1.bar(xdat,ydat)
plt.yticks(np.arange(0, 100.001, step=10))
plt.xlabel("States")
plt.ylabel("Shots measured")
```

![histo-left.png](qbOS%20Documentation%20220913/histo-left.png)

![histo-right.png](qbOS%20Documentation%20220913/histo-right.png)

And we can find the estimated quantum time in ms (for QB's commercial accelerators) simply through:

```
tqb.out_total_init_maxgate_readout_time[0][0][0]
```

```
tqb.out_total_init_maxgate_readout_time[0][1][0]
```

```
480.0
```

```
48000.0
```

Printing out the exact compiled/transpiled circuit instructions that qbOS/XACC compiler will send to QB hardware: 

- For this example, we set up the `loopback`:
    
    Open a Terminal in JupyterLab and run the command:
    
    `python3 /mnt/qb/bin/qbqe_if_model.py`
    
    ![Untitled](qbOS%20Documentation%20220913/Untitled%201.png)
    
    **Note: returned data when using the `loopback` are synthetic** and do not correspond to the input circuit nor to the results on real QB hardware.
    

Now issue the commands:

```python
tqb.acc = "loopback"
tqb.run()
```

And then inspect the JSON data sent to the QB hardware:

```python
print(tqb.out_qbjson[0][0])
```

```python
print(tqb.out_qbjson[0][1])
```

```python
# Result:

{"circuit":["Ry(q[0],1.5708)","Rx(q[0],3.14159)"],"command":"circuit","hwbackend":"gen1_canberra","init":[0,0,0,0,0,0,0,0,0,0,0,0],"measure":[[0,0]],"settings":{"cycles":1,"results":"normal","shots":1}}
```

```python
# Result:

{"circuit":["Ry(q[0],1.5708)","Rx(q[0],3.14159)"],"command":"circuit","hwbackend":"gen1_canberra","init":[0,0,0,0,0,0,0,0,0,0,0,0],"measure":[[0,0]],"settings":{"cycles":1,"results":"normal","shots":100}}
```

## 2.5 Controlled gates and basic quantum algorithms

Quantum computing also relies heavily on correlation, or *entanglement*, between qubits. This is achieved through gates that act on one qubit but are controlled by one or more others. The simplest of these is the controlled-not or CNOT gate. The CNOT, or *CX*, the gate is given one control qubit and one target qubit and performs a NOT, or *X*, operation on the target qubit if, but only if, the control qubit is in the $`|1\rangle`$ state. Their use is demonstrated in the following examples:

- **Example 2.5.1: Superdense coding**
    
    The gates presented so far are well illustrated by the [superdense coding protocol](https://en.wikipedia.org/wiki/Superdense_coding), which allows one to transmit classical information from one party to another, generally, two classical bits, using a single qubit. In a sense, it is a protocol opposite to [quantum teleportation](https://en.wikipedia.org/wiki/Quantum_teleportation).
    
    Let Alice and Bob be the two parties that wish to exchange two classical bits of information. A third party Charlie produces an entangled state of two qubits (applying a Hadamard gate to his first qubit, which serves as the control qubit for the following CNOT gate on the second qubit as the target) and gives Alice and Bob, each a qubit. Depending on the pair of classical bits that Alice wishes to send to Bob, she does one of the [following](https://qiskit.org/textbook/ch-algorithms/images/superdense_table1.png) operations on her qubit:
    
    For classical pair '00' she applies the identity  $`I`$ yielding the state $`|{00}\rangle + |{11}\rangle`$,
    
    For classical pair '10' she applies the operator $`X`$ yielding the state $`|{10}\rangle + |{01}\rangle`$,
    
    For classical pair '01' she applies the operator $`Z`$ yielding the state $`|{00}\rangle - |{11}\rangle`$,
    
    For classical pair '11' she applies the operator $`ZX`$ yielding the state $`-|{10}\rangle + |{01}\rangle`$,
    
    where the sent states are normalised by a factor of $`\sqrt{2}`$.
    
    Now Bob performs the reverse operation as Charlie, i.e. using the qubit he received from Alice as the control for a CNOT gate targeting the qubit he received from Charlie to disentangle them. He then applies a Hadamard gate to Alice's qubit and retrieves the two classical qubits sent by Alice by measuring both hers and Charlie's. Refer to [this](https://qiskit.org/textbook/ch-algorithms/images/superdense_table2.png) table to better understand the final operation done by Bob.
    
    - Step-by-step walkthrough
        
        The following Python notebook performs superdense coding protocol broadcast of '01' and '00':
        
        [qbOS_superdense.ipynb](qbOS%20Documentation%20220913/qbOS_superdense.ipynb)
        
    - Images of the output
        
        

The next two examples are, admittedly contrived, algorithms that demonstrate quantum utility:

- **Example 2.5.2: Quantum utility with Deutsch-Jozsa Algorithm**
    
    The [Deutsch-Jozsa algorithm](https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm) was the first example of a quantum algorithm that performed better than its best classical counterpart. 
    
    In our problem, we are given a secret Boolean function $`f`$, which takes a string of bits as input and returns either a 0 or 1 i.e.
    
    $`\hspace{1cm}f(\{x_0, x_1, x_2, ...\}) \rightarrow \text{0 or 1, where } x_n \text{ is 0 or 1}`$
    
    The property of the above Boolean function is that it is either balanced or constant. A balanced function will return 0's for exactly half of the inputs and 1's for the other half, whereas a constant function will return all 0's or all 1's for any input. The problem is to determine the nature of this function $`f`$ i.e. whether it is balanced or constant.
    
    Classically, in the best case, we require two queries to the oracle and in the worst case, we would require half of all possible inputs plus one query to ascertain the nature of $`f`$.
    
    The advantage that the Deutsch-Jozsa algorithm provides is that only a single query to $`f`$ is required to determine if the Boolean function is balanced or constant with 100% confidence! If $`f`$ is constant the final state consists entirely of "0" but if it is balanced then the final state contains at least one "1".
    
    Balanced functions may be identified by a wrapping string. The following circuit performs the Deutsch-Jozsa algorithm on a balanced function whose wrapping string is "101": see [here](https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C%22X%22%5D%2C%5B%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22X%22%2C1%2C%22X%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22X%22%2C1%2C%22X%22%5D%2C%5B%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22Measure%22%2C%22Measure%22%2C%22Measure%22%5D%5D%7D).
    
    - Step-by-step walkthrough ending at a plot of Quantum Utility
        
        **Concepts covered in the Jupyter notebook below**:
        
        - Circuit generation
        - Execution of an array of circuits
        - Extracting classical execution time
        - Extracting estimated quantum hardware execution time
        - Visualising Quantum Utility
        
        [qbOS_DJ.ipynb](qbOS%20Documentation%20220913/qbOS_DJ.ipynb)
        

### Visualising Quantum Utility

[DJ-alternative-q-util.ipynb](qbOS%20Documentation%20220913/DJ-alternative-q-util.ipynb)

![DJgrid (4).png](qbOS%20Documentation%20220913/DJgrid_(4).png)

The visualisation above shows that beyond 34 qubits, the speed of the Deutsch-Jozsa algorithm on forthcoming QB hardware is superior to a comparable classical algorithm (running on an AWS *m5a.large* virtual machine) that performs the same task.  However, the fidelity on QB hardware is below that of the classical algorithm.

- **Example 2.5.3: Quantum utility with Bernstein-Vazirani Algorithm**
    
    The [Bernstein-Vazirani algorithm](https://en.wikipedia.org/wiki/Bernstein%E2%80%93Vazirani_algorithm) can be viewed as an extension of the Deutsch-Jozsa algorithm.  In the problem, we have a secret message *s* (a bitstring) and an oracle *f* which is defined as:
    
     $`\hspace{1cm}f_s(x) = s \cdot x \: (\text{mod 2})`$
    
    where $`x`$ is the input string that we use as queries to the oracle, to find the secret string.
    
    The classical approach is to apply 
    
    $`\hspace{1cm} x = 2^i, \;\; \forall i \; \in \; [0, n-1]`$
    
    requiring *n* trials, where *n* is the number of bits in the secret string. This clearly has a runtime linear in *n*, while the Bernstein-Vazirani algorithm requires only one call to the function $`f_s(x)`$. It follows theoretically that the runtime is constant with respect to the size of *s*. In practice, however, the physical characteristics and limitations of the hardware cause the runtime to increase with an increasing number of qubits. 
    
    For a graphical view of this circuit, see [here](https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22Z%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22Measure%22%2C%22Measure%22%2C%22Measure%22%5D%5D%7D).
    
    - Step-by-step walkthrough showing the impact of noise
        
        The following Python notebook sets up a 2-by-2 experiment: it runs the Bernstein-Vazirani algorithm with a 14-qubit secret, and a 16-qubit secret; where both noise-free, as well as noise-enabled conditions, are examined:
        
        [qbOS_BV.ipynb](qbOS%20Documentation%20220913/qbOS_BV.ipynb)
        
    - Images of the output

As one might expect, all the simple gates in Section 2.3 have their controlled equivalents, *CY*, *CZ* and *CH.*

A list of available gates, together with mathematical representation and coding syntax is available in the Glossary of Tools and Quantum Gates.

