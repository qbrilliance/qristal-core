# 10. Parallel Operations in qbOS

qbOS supports asynchronous (non-blocking) dispatch of quantum jobs in the job table (array programming syntax) to multiple backend devices in a “*fire-and-forget*” fashion.

Specifically, the qbOS `run(i, j)` method executes a circuit instance indexed by `(i,j)` in a blocking manner, hence the caller will need to wait until the execution of that circuit is complete to proceed with other steps.

Therefore, the asynchronous job dispatch mechanism is designed to support:

- Non-blocking job submission: i.e., the circuit execution can be launched without blocking the caller. The main thread can continue useful work while waiting for the result to be available.
- Flexibility: users can specify how many backends should be *pooled* together for parallel execution.
- Scalability: it needs to be able to handle thousands of jobs, potentially hundreds of connected backends.
- User-friendly: consistent/similar API with the existing synchronous counterpart.

## 10.1 Asynchronous APIs and data structures

The following methods in `qbos.core()` can be used to execute circuits asynchronously. 

- `set_parallel_run_config(config_json)`

Specify a list of accelerator backends that should be participated in parallel job dispatch.

Currently, these backends are assigned jobs in a FIFO fashion.

**Example**:

```python
import qbos, json
tqb = qbos.core()
qpu_configs = {"accs": [{"acc": "qpp"},
                        {"acc": "aer"},
                        {"acc": "qb-lambda"}]} 

# Set up the pool of QPU for parallel task distribution
tqb.set_parallel_run_config(json.dumps(qpu_configs))
```

In short, we need to supply a JSON configuration that includes a list of accelerators (`accs` field). Each accelerator instance is specified by its name (`acc` field) and any other accelerator-specific settings if necessary (none is needed in the above example).

The above setting assumes that we want to use 3 simulators as the backends.

- `handle = tqb.run_async(i, j)`

Launch the job `(i, j)` (row `i`, column `j`) asynchronously (the function should return almost *immediately* without any blocking) and return a handle that the caller can use to wait for the result.

In particular, the `handle` has the following methods:

- `handle.complete()` returns `True`/`False` depending on the job status.
- `handle.qpu_name()` returns the name of the QPU accelerator that executed the job. Only valid once the job has been completed.
- `handle.get()` gets the string result. If not yet available, this call will wait till the result is ready.

<aside>
ℹ️ After the first successful call to `handle.get()`, subsequent calls will result in null values.

</aside>

- `handle.terminate()` terminate the underlying job. Do nothing if the job has been completed.

- `tqb.run_complete(i, j)`

Return `True`/`False` indicating if the result of the `(i,j)` run is available, thus can be retrieved in the `out_raws`

**Note**: users can use the `handle` that was returned by `run_async` to check this as well.