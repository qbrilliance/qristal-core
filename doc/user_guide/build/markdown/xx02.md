# 1. Quickstart

Using a small experimental design, let's run some circuits of the [Quantum Fourier Transform (QFT)](qbOS%20Documentation%20220913/Quantum%20Fourier%20Transform%20(QFT)%20086133df66464393834202921b561874.md).  We perform a 2-qubit QFT, and a 4-qubit QFT.  In both cases, we will perform both a noiseless and a noisy simulation.  

The concept of a **QPU Kernel and GUI circuit composition** appear without details for now â€” these concepts can be reviewed [here](qbOS%20Documentation%20220913/GUI%20circuit%20composition%20and%20conversion%20to%20QPU%20kern%204f46ef713a5743e192aa79ec6f804d5d.md).

[QFT Experiment Fixed Global Options](qbOS%20Documentation%20220913/QFT%20Experiment%20Fixed%20Global%20Options%20de0784ece18847ebb02a5475c69aca97.csv)

[QFT Experiment Design](qbOS%20Documentation%20220913/QFT%20Experiment%20Design%2097159967bced45808d9bbef5fc861dea.csv)

### **Step 1 of 3**: Start your qbOS environment

Access to qbOS requires a web browser, and a virtual machine (VM) host provided via any one of the following options:

[AWS Spot-Market instances](qbOS%20Documentation%20220913/AWS%20Spot-Market%20instances%20695d2d72ff0b4916aec906b3ac43b74a.md)

[Pawsey Nimbus Cloud](qbOS%20Documentation%20220913/Pawsey%20Nimbus%20Cloud%2039cb71b3471045b388e4593d7ae2d240.md)

Once you have completed the login to your VM host, use your Web browser to open: [http://localhost:8889](http://localhost:8889) 

![Untitled](qbOS%20Documentation%20220913/Untitled.png)

### **Step 2 of 3**: Python code that calls qbOS and executes all (four) corner conditions of the experiment

```python
import qbos
tqb = qbos.core()  # This object has access to the core API methods for circuit simulation
tqb.qb12()         # Set up some sensible defaults
```

> Setup conditions that apply to all experiment corners:
> 

```python
tqb.xasm = True    # Use XASM circuit format to access XACC's qft()    
tqb.sn = 1024      # Explicitly use 1024 shots
tqb.acc = "aer"    # Use the aer state-vector simulator
```

> Setup rows of the experiment table:
> 

```python
tqb.qn.clear()
tqb.qn.append(qbos.N([2]))  # 2-qubits for the top row
tqb.qn.append(qbos.N([4]))  # 4-qubits for the bottom row

qpu_kernel_qft_2 = '''
__qpu__ void QBCIRCUIT(qreg q) 
{
qft(q, {{"nq",2}});
Measure(q[1]);
Measure(q[0]);
}
'''

qpu_kernel_qft_4 = '''
__qpu__ void QBCIRCUIT(qreg q) 
{
qft(q, {{"nq",4}});
Measure(q[3]);
Measure(q[2]);
Measure(q[1]);
Measure(q[0]);
}
'''

tqb.instring.clear()
tqb.instring.append(qbos.String([qpu_kernel_qft_2]))   # QPU Kernel for the top row
tqb.instring.append(qbos.String([qpu_kernel_qft_4]))   # QPU Kernel for the bottom row
```

> Enable the noise model
> 

```python
tqb.noise.clear()
tqb.noise.append(qbos.Bool([False, True]))  # noise is False (disabled) for the left (index 0) column, True (enabled) for the right column (index 1)
```

> Run the simulation in all experiment corners
> 

```python
tqb.run()    
```

### **Step 3 of 3**: Inspect the results (shot counts)

After the code from Step 2 has finished executing, you can inspect shot counts (in each state and two easy-to-understand formats) by calling: `tqb.out_raw[0]` or `tqb.out_count[0]` for the first experiment and `tqb.out_raw[1]` or `tqb.out_count[1]` for the second one. More details on how to use Python codes to inspect settings or results, as configured for experiments above, are listed in the tables below:

[QFT Experiment - Python code for viewing fixed global options](qbOS%20Documentation%20220913/QFT%20Experiment%20-%20Python%20code%20for%20viewing%20fixed%20glo%20d4800077ec6f41edbee7a34819f21dcc.csv)

[QFT Experiment - Python code for viewing shot results](qbOS%20Documentation%20220913/QFT%20Experiment%20-%20Python%20code%20for%20viewing%20shot%20resu%20ba1d8065630f480fbb0e2dcf8d999fb4.csv)

